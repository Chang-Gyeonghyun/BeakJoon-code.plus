## 15988 문제

정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.

- 1+1+1+1
- 1+1+2
- 1+2+1
- 2+1+1
- 2+2
- 1+3
- 3+1

정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 1,000,000보다 작거나 같다.

## 출력

각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.

## 예제 입력 1

```
3
4
7
10
```

## 예제 출력 1

```
7
44
274
```

### My code

```python
T = int(input())
dp = [0 for _ in range(1000001)]
MOD = 1000000009
stack = []
dp[1] = 1
dp[2] = 2
dp[3] = 4
for i in range(T):
    start = 4
    n = int(input())
    if stack:
        start = max(stack)
    for i in range(start,n+1):
        dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % MOD
    stack.append(n)
        
    print(dp[n])
```

### Solution

1,2,3 까지의 경우의 수를 세어보고 규칙을 찾아보자

1: 1

2: 11 2

3: 111 12 21 3

4부터는 이러한 규칙이 존재한다. 1111 121 211 31 까지는 3에서 나올 경우의 수에 1을 더하면 되고 112 22 와 같이 2에서 나올 수 있는 경우의 수에 2를 더하는 방식, 그리고 13과 같이 1에서 나올 수 있는 경우의 수에서 3을 더하면 된다.

이것을 점화식으로 세우면 dp[i] = (dp[i-1] + dp[i-2] + dp[i-3])가 된다.

처음부터 문제를 올곧게 접근했으나 메모리 초과가 떠서 헤매었더니 알고 보니 문제 조건에서 1000000009를 안 나눠서 그랬다. 다음부터는 한 번에 성공해보자

## 1149 문제

RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로?있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

- 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
- N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
- i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

## 입력

첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

## 예제 입력 1

```
3
26 40 83
49 60 57
13 89 99
```

## 예제 출력 1

```
96
```

### My code

```python
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]
dp = [[0] * 3 for _ in range(N)]  # dp[i][j]: i번째 집을 j색으로 칠했을 때의 최소 비용

for i in range(N):
    if i == 0:
        dp[i] = arr[i]
    else:
        dp[i][0] = arr[i][0] + min(dp[i-1][1], dp[i-1][2])  # 현재 집을 빨강으로 칠했을 때의 최소 비용
        dp[i][1] = arr[i][1] + min(dp[i-1][0], dp[i-1][2])  # 현재 집을 초록으로 칠했을 때의 최소 비용
        dp[i][2] = arr[i][2] + min(dp[i-1][0], dp[i-1][1])  # 현재 집을 파랑으로 칠했을 때의 최소 비용

print(min(dp[N-1]))  # 마지막 집을 각 색상으로 칠한 경우 중에서 최소 비용을 선택
```

### Solution

DP를 이용하여 풀었다. 각 RGB 값들 중 한 가지를 골랐을 때, 이전 최솟값에 더하는 형식이다.

2차원 배열로 어떠한 색깔을 가져왔을 때, 해당 최솟값을 나타내는 모든 경우의 수가 담긴다.

## 1309 문제

어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.

!https://www.acmicpc.net/upload/201004/dnfl.JPG

이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.

동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.

## 입력

첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.

## 출력

첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.

## 예제 입력 1

```
4
```

## 예제 출력 1

```
41
```

### My code

```python
N = int(input())
dp = [[0,0,0] for _ in range(N+1)]
dp[0] = [1,1,1]
for i in range(1, N):
    dp[i][0] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) % 9901
    dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % 9901
    dp[i][2] = (dp[i-1][0] + dp[i-1][1]) % 9901
print(sum(dp[N-1]) % 9901)
```

### Solution

dp 알고리즘을 이용하여 풀었다. 풀이는 간단하다. 사자가 있을 때를 1, 없을 때를 0으로 구분 했을 때,

00 01 10 총 3가지의 경우의 수가 존재한다. 이 때, 00일 경우는 그 전 번째 열에서 00 01 10에 해당하는 경우 모두가 가능하다. 그리고 01일 경우는 00 10만, 10일 경우는 00 01만 가능하다. 이러한 알고리즘을 점화식으로 세웠을 때

    dp[i][0] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) % 9901
    dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % 9901
    dp[i][2] = (dp[i-1][0] + dp[i-1][1]) % 9901

가 된다.

## 11057 문제

오르막 수는 수의 자리가 오름차순을?이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다.

예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다.

수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오. 수는 0으로 시작할 수 있다.

## 입력

첫째 줄에 N (1 ≤ N ≤ 1,000)이 주어진다.

## 출력

첫째 줄에 길이가 N인 오르막 수의 개수를 10,007로 나눈 나머지를?출력한다.

## 예제 입력 1

```
1
```

## 예제 출력 1

```
10
```

### My code

```python
N = int(input())
MOD = 10007
dp = [[0] * 10 for _ in range(N+1)]
dp[0] = [1] * 10

for i in range(1, N):
    for j in range(10):
        dp[i][j] = sum(dp[i-1][k] for k in range(j+1)) % MOD

print(sum(dp[N-1]) % MOD)
```

### Solution

DP알고리즘을 이용하여 풀었다. 

```python
for i in range(1, N):
    dp[i][9] = (dp[i-1][0] + dp[i-1][1]+ dp[i-1][2] + dp[i-1][3] + dp[i-1][4] + dp[i-1][5] + dp[i-1][6] + dp[i-1][7] + dp[i-1][8] + dp[i-1][9]) % MOD
    dp[i][8] = (dp[i-1][0] + dp[i-1][1]+ dp[i-1][2] + dp[i-1][3] + dp[i-1][4] + dp[i-1][5] + dp[i-1][6] + dp[i-1][7] + dp[i-1][8]) % MOD
    dp[i][7] = (dp[i-1][0] + dp[i-1][1]+ dp[i-1][2] + dp[i-1][3] + dp[i-1][4] + dp[i-1][5] + dp[i-1][6] + dp[i-1][7]) % MOD
    dp[i][6] = (dp[i-1][0] + dp[i-1][1]+ dp[i-1][2] + dp[i-1][3] + dp[i-1][4] + dp[i-1][5] + dp[i-1][6]) % MOD
    dp[i][5] = (dp[i-1][0] + dp[i-1][1]+ dp[i-1][2] + dp[i-1][3] + dp[i-1][4] + dp[i-1][5]) % MOD
    dp[i][4] = (dp[i-1][0] + dp[i-1][1]+ dp[i-1][2] + dp[i-1][3] + dp[i-1][4]) % MOD
    dp[i][3] = (dp[i-1][0] + dp[i-1][1]+ dp[i-1][2] + dp[i-1][3]) % MOD
    dp[i][2] = (dp[i-1][0] + dp[i-1][1]+ dp[i-1][2]) % MOD
    dp[i][1] = (dp[i-1][0] + dp[i-1][1]) % MOD
```

위와 같이 9일 경우는 그 전 단계에서 0~9까지 전부 가능하고 한 숫자씩 내려갈 수록 가능한 경우의 수는 한 단계씩 줄어든다. 위의 로직을 함축하면 답이다.

## 2156 문제

효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.

1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오.

예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.

## 입력

첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.

## 출력

첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.

## 예제 입력 1

```
6
6
10
13
9
8
1
```

## 예제 출력 1

```
33
```

### My code

```python
N = int(input())
arr = [0]  # 0번 인덱스는 사용하지 않으므로 더미 데이터 0을 추가
for _ in range(N):
    n = int(input())
    arr.append(n)

dp = [0] * (N+3)  # dp 배열 크기를 N+3으로 확장
dp[1] = arr[1]
if N>=2:
    dp[2] = arr[1] + arr[2]
if N>=3:
    dp[3] = max(arr[1] + arr[2], arr[1] + arr[3], arr[2] + arr[3])

for i in range(4, N+1):
    dp[i] = max(dp[i-2] + arr[i], arr[i] + arr[i-1] + dp[i-3], dp[i-1])

print(dp[N])
```

### Solution

DP를 이용하여 풀었다.

3잔 연속의 포도주는 마시지 못한다고 되어있다. 따라서 i번째 포도주를 마실 때, 전 번째 포도주를 안 마실 경우, 또한 전 번째 포도주를 마셨고 i번째 포도주를 마신다는 가정은 전 전 번째 포도주를 마시지 않았다는 뜻이니까 i-3번째 포도주와 i-1, i번째 포도주를 마실 경우가 있다. 그리고 i-1번째까지 마셨고 i번째를 마시지 않았을 경우도 포함한다. 이유는 i-2번째 i-1번째를 마실 경우가 더 값이 크게 나올 수 있기 때문이다.

이 3가지 경우를 점화식으로 계산하면 

dp[i] = max(dp[i-2] + arr[i], arr[i] + arr[i-1] + dp[i-3], dp[i-1])

위와 같이 표기되고, 여기서 주의할 점은 dp[1], dp[2], dp[3] 값을 미리 구해줬는데 n값이 따라 out of list가 된다는 것이다. 이 점에서 N의 크기에 따라 코드가 작동되도록 수정해주면 답이 완성된다.

## 1932 문제

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

위 그림은 크기가 5인 정수 삼각형의 한 모습이다.

맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.

삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.

## 입력

첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.

## 출력

첫째 줄에?합이 최대가 되는 경로에 있는 수의 합을 출력한다.

## 예제 입력 1

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

## 예제 출력 1

```
30
```

### My code

```python
N = int(input())
arr = [[] for _ in range(501)]
dp = [[0 for _ in range(501)] for _ in range(501)]

for i in range(N):
    temp = list(map(int, input().split()))
    arr[i+1] = temp

for i in range(1, N+1):
    for j in range(1, i+1):
        dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + arr[i][j-1]

print(max(dp[N]))
```

### Solution

DP를 이용하여 풀었다.

2차원 배열로 접근하였고, 예시를 들면 i번째 행에 2번째 열이라고 해보자. 이 값은 i-1번째 행의 1번째 열과 i-1번째 행의 2번째 열 사이에 존재한다. 이 두 개의 dp값들 중 최댓값을 고르고 자신의 값을 더하면 그것이 자신의 dp값이 된다.

하지만 첫 번째 열의 경우 0번째 숫자가 없기 때문에 배열 자체를 1번 인덱스부터 시작하였다. 0번 인덱스를 비워두고 시작함으로써 문제는 해결된다.

## 11055 문제

수열 A가 주어졌을 때, 그 수열의 증가하는 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 인 경우에 합이 가장 큰 증가하는 부분 수열은 A = {**1**, 100,?**2**,?**50**,?**60**, 3, 5, 6, 7, 8} 이고, 합은 113이다.

## 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai?≤ 1,000)

## 출력

첫째 줄에 수열 A의 합이 가장 큰 증가하는 부분 수열의 합을 출력한다.

## 예제 입력 1

```
10
1 100 2 50 60 3 5 6 7 8
```

## 예제 출력 1

```
113
```

### My code

```python
n=int(input())
array=list(map(int, input().split()))

d=[1]*n
d[0]=array[0]
for i in range(1,n):
  for j in range(i):
    if array[j]<array[i]:
      d[i]=max(d[i], d[j]+array[i])
    else:
      d[i]=max(d[i], array[i])

print(max(d))
```

### Solution

DP를 이용하여 풀었다. 이중 반복문을 이용하여 각 i번째 숫자마다 그 전 번째 숫자만큼 반복한다. 그 중 i번째 숫자보다 작은 수가 나올 경우 해당 dp값에 자신의 값을 더한 것으로 업데이트 한다.

## 11722 문제

수열 A가 주어졌을 때, 가장 긴 감소하는?부분?수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 30, 10, 20, 20, 10} 인 경우에 가장 긴 감소하는 부분?수열은?A = {10,?**30**, 10,?**20**, 20,?**10**}? 이고, 길이는 3이다.

## 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai?≤ 1,000)

## 출력

첫째 줄에 수열 A의 가장 긴 감소하는 부분 수열의 길이를 출력한다.

## 예제 입력 1

```
6
10 30 10 20 20 10
```

## 예제 출력 1

```
3
```

### My code

```python
n=int(input())
array=list(map(int, input().split()))

d=[0]*n
d[0]=1
for i in range(1,n):
  for j in range(i):
    if array[j]>array[i]:
      d[i]=max(d[i], d[j]+1)
    else:
      d[i]=max(d[i], 1)

print(max(d))
```

### Solution

DP 알고리즘을 이용하여 풀었다.  전 문제에서 접근한 것과 비슷하게 풀었다. 단지 합산이 아니고 숫자를 세는 것, 그리고 증가가 아니라 감소라는 점만 유의해서 수정하면 된다.

## 11054 문제

수열 S가 어떤 수 Sk를 기준으로 S1?< S2?< ... Sk-1?< Sk?> Sk+1?> ... SN-1?> SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20,?**30**, 25, 20}과 {10, 20, 30,?**40**}, {**50**, 40, 25, 10} 은 바이토닉 수열이지만, ?{1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai?≤ 1,000)

## 출력

첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.

## 예제 입력 1

```
10
1 5 2 1 4 3 4 5 2 1
```

## 예제 출력 1

```
7
```

### My code

```python
n = int(input())
array = list(map(int, input().split()))

dp = [[1, 1] for _ in range(n)]

for i in range(1, n):
    for j in range(i):
        if array[i] > array[j]:
            dp[i][0] = max(dp[i][0], dp[j][0] + 1)

for i in range(n - 1, -1, -1):
    for j in range(n - 1, i - 1, -1):
        if array[i] > array[j]:
            dp[i][1] = max(dp[i][1], dp[j][1] + 1)

maximum = 0
for i in range(n):
    maximum = max(maximum, dp[i][0] + dp[i][1] - 1)  # 중복되는 i번째 원소를 빼줍니다.

print(maximum)
```

### Solution

전에 풀었던 최대 길이 부분 수열의 문제를 응용하였다.

dp[i][0]은 i 기준 전 번째 중 증가하는 수열을, dp[i][1]는 i기준 그 다음 번째 중 감소하는 수열을 나타낸다. 총 두 개의 리스트를 합산하여 maximum값을 계속 업데이트 해준다.

## 13396 문제

n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다. 또, 수열에서 수를 하나 제거할 수 있다. (제거하지 않아도 된다)

예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 수를 제거하지 않았을 때의?정답은 12+21인 33이 정답이 된다.

만약, -35를 제거한다면, 수열은?10, -4, 3, 1, 5, 6, 12, 21, -1이 되고, 여기서 정답은 10-4+3+1+5+6+12+21인 54가 된다.

## 입력

첫째 줄에 정수 n(1?≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

## 출력

첫째 줄에 답을 출력한다.

## 예제 입력 1

```
10
10 -4 3 1 5 6 -35 12 21 -1
```

## 예제 출력 1

```
54
```

### Code

```python
N = int(input())
a = list(map(int, input().split()))
dp = [[0] * N for _ in range(2)]
dp[0][0] = a[0]
dp[1][0] = -1000
for i in range(1, N):
    dp[0][i] = max(dp[0][i - 1] + a[i], a[i])
    dp[1][i] = max(dp[0][i - 1], dp[1][i - 1] + a[i])
print(max(max(dp[0]), max(dp[1])))
```

### Solution

dp를 이차원 배열로 초기화를 시켰다. 현재 인덱스를 무조건 포함하는 dp[0][i]와

이전 인덱스까지 전부 더한 합과 현재 인덱스를 제외하여 비교하는 dp[1][i]로 이루어져 있다.

## 2133 문제

3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를?구해보자.

## 입력

첫째 줄에 N(1 ≤ N ≤ 30)이 주어진다.

## 출력

첫째 줄에 경우의 수를 출력한다.

## 예제 입력 1

```
2
```

## 예제 출력 1

```
3
```

### Code

```python
n = int(input())
dp = [0] *(n+1)
if n>=2:
    dp[2] = 3
if n >= 4:
    dp[4] = 11
for i in range(6, n+1, 2):
    dp[i] = dp[i-2] * 3 + sum(dp[:i-2]) * 2 + 2
    
print(dp[n])
```
### Solution

dp를 이용하여 풀었다. 배열 크기는 n+1로 선언하였고 짝수일 때만 타일 형성이 가능하다.

따라서 반복문으로 step을 2씩 건너 뛰었다. dp[2]일 경우는 3가지가 존재하고 이것을 동적으로 계속 사용한다, 4번째 인덱스부터는 또 다른 새로운 타일을 형성 할 수 있다.

아래 그림은 3×12 벽을 타일로 채운 예시이다.

!https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/images/2663_1.jpg

3번째부터 6번째 열까지 타일을 보면 된다. 이러한 타일은 각 i마다 새로운 타일을 형성할 수 있다.

dp[i]번째 인덱스는 (짝수라는 가정) dp[i-2]번째의 타일에서 dp[2]에 해당하는 3가지를 추가로 만들 수 있다.

또한 dp[i-4]에서 dp[4]에서 만들어진 새로운 타일 2개를 넣음으로써 타일을 만들 수 있다,

방금 위와 같은 방안은 dp[i-6], dp[i-8]과 같이 계속해서 두 개씩 만들 수 있다, 왜냐하면 타일은 각 i마다 새로운 타일을 형성할 수 있다. 라고 위에서 언급했기 때문이다.  이렇게 dp를 이용한 타일들에 현재 새로운 타일을 만드는 가능한 수 2까지 더한다면 

점화식은 

dp[i] = dp[i-2] * 3 + sum(dp[:i-2]) * 2 + 2 이렇게 형성이 된다.